---
phase: 24-e-commerce-events
plan: 02
type: execute
wave: 2
depends_on: [24-01]
files_modified:
  - src/components/cart/cart-summary.tsx
  - src/components/analytics/purchase-tracker.tsx
  - src/app/bevestiging/page.tsx
autonomous: true
requirements: [ECOM-03, ECOM-04, ECOM-05, ECOM-06]

must_haves:
  truths:
    - "GA4 DebugView shows a begin_checkout event with items array and EUR value when a user clicks the checkout button, before the Shopify redirect fires"
    - "GA4 DebugView shows a purchase event on /bevestiging with a transaction_id and the full items array matching what was in the cart"
    - "Refreshing /bevestiging after a completed checkout does not fire a second purchase event"
    - "Cart contents are snapshot to sessionStorage before the clearCart() call and Shopify redirect"
    - "The Shopify invoiceUrl is decorated with the _gl linker parameter for cross-domain GA4 session continuity"
  artifacts:
    - path: "src/components/cart/cart-summary.tsx"
      provides: "begin_checkout event, sessionStorage snapshot, _gl linker decoration"
      contains: "trackBeginCheckout"
    - path: "src/components/analytics/purchase-tracker.tsx"
      provides: "Purchase event firing with dual-layer deduplication"
      exports: ["PurchaseTracker"]
    - path: "src/app/bevestiging/page.tsx"
      provides: "PurchaseTracker component mounted on confirmation page"
      contains: "PurchaseTracker"
  key_links:
    - from: "src/components/cart/cart-summary.tsx"
      to: "src/lib/analytics/index.ts"
      via: "import { trackBeginCheckout }"
      pattern: "import.*trackBeginCheckout.*from.*@/lib/analytics"
    - from: "src/components/cart/cart-summary.tsx"
      to: "sessionStorage"
      via: "sessionStorage.setItem('purchase_snapshot', ...)"
      pattern: "sessionStorage\\.setItem\\('purchase_snapshot'"
    - from: "src/components/analytics/purchase-tracker.tsx"
      to: "src/lib/analytics/index.ts"
      via: "import { trackPurchase }"
      pattern: "import.*trackPurchase.*from.*@/lib/analytics"
    - from: "src/components/analytics/purchase-tracker.tsx"
      to: "sessionStorage"
      via: "sessionStorage.getItem('purchase_snapshot')"
      pattern: "sessionStorage\\.getItem\\('purchase_snapshot'\\)"
    - from: "src/app/bevestiging/page.tsx"
      to: "src/components/analytics/purchase-tracker.tsx"
      via: "import { PurchaseTracker }"
      pattern: "import.*PurchaseTracker.*from.*@/components/analytics/purchase-tracker"
---

<objective>
Add begin_checkout event with sessionStorage cart snapshot and _gl linker decoration to CartSummary, then create PurchaseTracker component for /bevestiging that fires purchase event with dual-layer deduplication.

Purpose: Complete the GA4 e-commerce funnel from checkout initiation through purchase confirmation, with reliable cross-domain session continuity and purchase event deduplication.
Output: CartSummary fires begin_checkout and snapshots cart data; PurchaseTracker fires deduplicated purchase event on /bevestiging.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-e-commerce-events/24-CONTEXT.md
@.planning/phases/24-e-commerce-events/24-RESEARCH.md
@.planning/phases/24-e-commerce-events/24-01-SUMMARY.md
@src/lib/analytics/index.ts
@src/components/cart/cart-summary.tsx
@src/app/bevestiging/page.tsx
@src/lib/cart/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add begin_checkout event, sessionStorage snapshot, and _gl linker decoration to CartSummary</name>
  <files>src/components/cart/cart-summary.tsx</files>
  <action>
Import `trackBeginCheckout` from `@/lib/analytics` and add `GA4EcommerceItem` type import into CartSummary.

Modify `handleCheckout()` to add three things in the correct order:

**Step 1: Fire begin_checkout BEFORE the fetch() call (per Claude's discretion recommendation: fire on button click = checkout intention).**

Generate a transactionId and fire begin_checkout immediately after `setError(null)`:

```typescript
const transactionId = `pb-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`

trackBeginCheckout(
  items.map(item => ({
    item_id: item.productId,
    item_name: item.productName,
    price: item.priceInCents / 100,  // cents to EUR
    quantity: item.quantity,
  })),
  getTotalPrice() / 100  // cents to EUR
)
```

**Step 2: Write sessionStorage snapshot AFTER receiving invoiceUrl but BEFORE clearCart() and redirect (ECOM-06).**

Inside the `if (response.ok && data.invoiceUrl)` block, before `clearCart()`:

```typescript
const snapshot = {
  transactionId,
  items: items.map(item => ({
    item_id: item.productId,
    item_name: item.productName,
    price: item.priceInCents / 100,
    quantity: item.quantity,
  })),
  totalValue: getTotalPrice() / 100,
}
sessionStorage.setItem('purchase_snapshot', JSON.stringify(snapshot))
```

Note: The snapshot must be written BEFORE clearCart() because the cart store is cleared synchronously and items would be empty after.

**Step 3: Decorate the invoiceUrl with the _gl linker parameter for cross-domain GA4 session continuity (per locked decision).**

Add a `decorateWithGlLinker` helper function inside the file (not exported — internal to cart-summary). This function:

1. Checks if `window.google_tag_data?.glBridge?.generate` exists (undocumented but widely-used gtag.js utility)
2. Reads the `_ga` cookie from `document.cookie` using regex
3. Optionally reads the `_ga_{MEASUREMENT_ID}` session cookie
4. Calls `glBridge.generate()` with the cookie values to get the `_gl` parameter
5. Appends `_gl=<value>` to the URL
6. Wraps everything in try-catch — if anything fails, returns the original URL (graceful degradation)

Type the window extension inline:
```typescript
function decorateWithGlLinker(url: string): string {
  try {
    const win = window as Window & {
      google_tag_data?: {
        glBridge?: {
          generate: (cookies: Record<string, string>) => string
        }
      }
    }

    if (!win.google_tag_data?.glBridge?.generate) return url

    const getCookie = (name: string): string | undefined => {
      const match = document.cookie.match(new RegExp(`(?:^|; )${name}=([^;]*)`))
      return match ? decodeURIComponent(match[1]) : undefined
    }

    const gaClientId = getCookie('_ga')
    if (!gaClientId) return url

    const cookies: Record<string, string> = {
      _ga: gaClientId.replace(/^GA\d+\.\d+\./, ''),
    }

    const measurementId = process.env.NEXT_PUBLIC_GA4_ID?.replace('G-', '')
    if (measurementId) {
      const sessionCookie = getCookie(`_ga_${measurementId}`)
      if (sessionCookie) {
        cookies[`_ga_${measurementId}`] = sessionCookie.replace(/^GS\d+\.\d+\./, '')
      }
    }

    const glParam = win.google_tag_data.glBridge.generate(cookies)
    if (!glParam) return url

    const separator = url.includes('?') ? '&' : '?'
    return `${url}${separator}_gl=${encodeURIComponent(glParam)}`
  } catch {
    return url
  }
}
```

Then replace `window.location.href = data.invoiceUrl` with:
```typescript
window.location.href = decorateWithGlLinker(data.invoiceUrl)
```

The `transactionId` variable must be declared at the top of `handleCheckout()` (before the try block) so it's accessible in both the begin_checkout call and the snapshot. Move it to be declared right after `setError(null)`.

The complete modified flow inside handleCheckout:
1. `setLoading(true)`, `setError(null)`
2. Generate `transactionId`
3. Fire `trackBeginCheckout()` with items and total
4. `fetch('/api/checkout', ...)`
5. On success: write sessionStorage snapshot, `clearCart()`, `localStorage.removeItem('checkout_started')`, `window.location.href = decorateWithGlLinker(data.invoiceUrl)`
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npm run build` — build succeeds. Verify in code: begin_checkout fires before fetch, sessionStorage snapshot written before clearCart, invoiceUrl decorated with decorateWithGlLinker, try-catch around _gl decoration.</verify>
  <done>CartSummary handleCheckout fires begin_checkout with EUR items and total, writes sessionStorage purchase snapshot with transactionId before clearCart, and decorates the Shopify invoiceUrl with _gl linker parameter for cross-domain GA4 continuity. _gl decoration fails gracefully if gtag.js not loaded or no _ga cookie.</done>
</task>

<task type="auto">
  <name>Task 2: Create PurchaseTracker component and mount on /bevestiging</name>
  <files>src/components/analytics/purchase-tracker.tsx, src/app/bevestiging/page.tsx</files>
  <action>
**Part A: Create PurchaseTracker client component (ECOM-04, ECOM-05)**

Create `src/components/analytics/purchase-tracker.tsx` as a headless client component:

```typescript
'use client'

import { useEffect } from 'react'
import { trackPurchase } from '@/lib/analytics'

export function PurchaseTracker() {
  useEffect(() => {
    try {
      const raw = sessionStorage.getItem('purchase_snapshot')
      if (!raw) return  // No snapshot = no purchase to track (direct navigation or no checkout)

      const { transactionId, items, totalValue } = JSON.parse(raw)
      if (!transactionId) return

      // Layer 1: sessionStorage deduplication (same browser session refresh)
      const dedupeKey = `purchase_tracked_${transactionId}`
      if (sessionStorage.getItem(dedupeKey)) return

      // Layer 2: localStorage deduplication (cross-session, e.g. bookmark + return)
      if (localStorage.getItem(dedupeKey)) return

      trackPurchase(transactionId, items, totalValue)

      // Mark as tracked in both stores
      sessionStorage.setItem(dedupeKey, '1')
      localStorage.setItem(dedupeKey, '1')

      // Clear the snapshot — purchase tracking is complete
      sessionStorage.removeItem('purchase_snapshot')
    } catch {
      // Fail silently — analytics is non-critical
    }
  }, [])

  return null  // Headless component, no UI
}
```

Key implementation details:
- Reads `purchase_snapshot` from sessionStorage (written by CartSummary Task 1)
- Two-layer deduplication per ECOM-05: sessionStorage flag prevents same-session refresh duplicates, localStorage flag prevents cross-session duplicates
- Dedup key format: `purchase_tracked_{transactionId}` per locked decision (CONTEXT.md says "purchase_tracked_{orderId}" — transactionId IS the orderId in this architecture)
- Clears the snapshot after successful tracking to prevent stale data
- Entire block wrapped in try-catch — analytics must never break the confirmation page
- No Suspense boundary needed because PurchaseTracker does NOT use useSearchParams (reads from sessionStorage in useEffect only)
- Returns null — this is a side-effect-only component

**Part B: Mount PurchaseTracker on /bevestiging page (ECOM-04)**

Modify `src/app/bevestiging/page.tsx` to:
1. Add import: `import { PurchaseTracker } from '@/components/analytics/purchase-tracker'`
2. Add `<PurchaseTracker />` as the first child inside the outer `<div>`, before the existing content `<div>`:

```tsx
export default function ConfirmationPage() {
  return (
    <div className="px-6 py-20 sm:py-28">
      <PurchaseTracker />
      <div className="mx-auto max-w-lg text-center">
        {/* ... existing page content unchanged ... */}
      </div>
    </div>
  )
}
```

The existing page content (success icon, heading, steps, link) remains completely unchanged. PurchaseTracker renders null so it has no visual impact.

The page stays a server component (no 'use client' directive needed) — PurchaseTracker is a client component imported into a server component, which is valid in Next.js App Router. The `export const metadata` stays intact.
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npm run build` — build succeeds. Verify: purchase-tracker.tsx exports PurchaseTracker, has 'use client' directive, reads from sessionStorage, has dual-layer deduplication with both sessionStorage and localStorage, clears snapshot after tracking. bevestiging/page.tsx imports and renders PurchaseTracker, keeps existing metadata export.</verify>
  <done>PurchaseTracker fires a deduplicated purchase event on /bevestiging using sessionStorage snapshot from checkout. Dual-layer deduplication (sessionStorage + localStorage) prevents duplicate events on refresh or return. Component mounted on /bevestiging as a headless client component with no visual impact. Entire flow is wrapped in try-catch for graceful degradation.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` completes successfully
3. CartSummary fires begin_checkout before fetch() call with EUR prices
4. CartSummary writes sessionStorage purchase_snapshot before clearCart()
5. CartSummary decorates invoiceUrl with _gl parameter (graceful degradation on failure)
6. PurchaseTracker reads sessionStorage snapshot and fires trackPurchase
7. PurchaseTracker has dual-layer deduplication (sessionStorage + localStorage)
8. PurchaseTracker clears snapshot after successful tracking
9. /bevestiging page mounts PurchaseTracker, existing content unchanged
10. No Suspense boundary needed (no useSearchParams)
</verification>

<success_criteria>
- begin_checkout fires on checkout button click with correct items array and EUR total
- sessionStorage purchase_snapshot contains transactionId, items array, and totalValue
- Shopify invoiceUrl is decorated with _gl cross-domain linker parameter
- purchase event fires once on /bevestiging with data from sessionStorage snapshot
- Page refresh on /bevestiging does NOT fire a second purchase event
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-e-commerce-events/24-02-SUMMARY.md`
</output>
