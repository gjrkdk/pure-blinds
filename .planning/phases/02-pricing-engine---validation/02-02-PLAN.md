---
phase: 02-pricing-engine---validation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/api/pricing/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/pricing with valid dimensions returns 200 with priceInCents"
    - "POST /api/pricing with width < 10 returns 400 with validation error"
    - "POST /api/pricing with height > 200 returns 400 with validation error"
    - "POST /api/pricing with non-number inputs returns 400 with validation error"
    - "POST /api/pricing with missing fields returns 400 with validation error"
    - "POST /api/pricing returns normalizedWidth and normalizedHeight in response"
    - "Response priceInCents is always an integer (no decimals)"
    - "Malformed JSON body returns 500 with error message"
  artifacts:
    - path: "src/app/api/pricing/route.ts"
      provides: "POST endpoint for price calculation"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/pricing/route.ts"
      to: "src/lib/pricing/validator.ts"
      via: "Zod safeParse validation"
      pattern: "DimensionInputSchema\\.safeParse"
    - from: "src/app/api/pricing/route.ts"
      to: "src/lib/pricing/calculator.ts"
      via: "calculatePrice function call"
      pattern: "calculatePrice\\("
---

<objective>
Create the POST /api/pricing route handler that composes Zod validation with the pure pricing calculator to accept dimension inputs and return calculated prices.

Purpose: This is the HTTP interface to the pricing engine. It handles request parsing, validation error formatting, and response serialization while delegating all business logic to the pure pricing library.
Output: A single route handler file that fulfills PRICE-01, PRICE-02 requirements and wires the validation + calculation layers together.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-pricing-engine---validation/02-RESEARCH.md
@.planning/phases/02-pricing-engine---validation/02-01-SUMMARY.md

@src/lib/pricing/types.ts
@src/lib/pricing/validator.ts
@src/lib/pricing/calculator.ts
@src/app/api/health/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /api/pricing route handler</name>
  <files>src/app/api/pricing/route.ts</files>
  <action>
    Create `src/app/api/pricing/route.ts` with a POST handler following the three-layer pattern:

    1. Import NextResponse from 'next/server'
    2. Import DimensionInputSchema from '@/lib/pricing/validator'
    3. Import calculatePrice from '@/lib/pricing/calculator'

    4. Export async function POST(request: Request):
       a. Wrap entire body in try/catch
       b. Parse request body: `const body = await request.json()`
       c. Validate with Zod: `const result = DimensionInputSchema.safeParse(body)`
       d. If validation fails (!result.success):
          - Return NextResponse.json with status 400
          - Body: { error: 'Invalid dimensions', details: result.error.issues }
          - The details array gives field-level errors (path, message) for frontend consumption
       e. If validation succeeds:
          - Call calculatePrice(result.data.width, result.data.height)
          - Return NextResponse.json with status 200
          - Body: the PricingResponse object from calculatePrice (priceInCents, normalizedWidth, normalizedHeight, originalWidth, originalHeight)
       f. Catch block:
          - For any unexpected error, return NextResponse.json with status 500
          - Body: { error: 'Internal server error', message: error.message if Error instance, else 'Unknown error' }

    Follow the existing pattern in src/app/api/health/route.ts for import style and response formatting.

    Important:
    - Use POST method (not GET) to avoid Next.js caching issues
    - Use .safeParse() not .parse() to avoid throwing on invalid input
    - Do NOT add any authentication or rate limiting (not needed for Phase 2)
    - The route handler is thin: validation + delegation + error formatting only
  </action>
  <verify>
    0. Compile check: `npx tsc --noEmit` passes
    1. Start dev server in background: `npm run dev &` (wait a few seconds for startup)
    2. Test valid request:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 50, "height": 100}' | jq .`
       Expected: 200 response with priceInCents (integer), normalizedWidth: 50, normalizedHeight: 100
    3. Test normalization:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 71, "height": 85}' | jq .`
       Expected: 200, normalizedWidth: 80, normalizedHeight: 90
    4. Test validation - too small:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 5, "height": 50}' | jq .`
       Expected: 400, error "Invalid dimensions", details array with width error
    5. Test validation - too large:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 50, "height": 300}' | jq .`
       Expected: 400, error "Invalid dimensions"
    6. Test validation - non-number:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": "abc", "height": 50}' | jq .`
       Expected: 400
    7. Test validation - missing fields:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{}' | jq .`
       Expected: 400
    8. Test boundary values AND integer verification:
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 10, "height": 10}' | jq '.priceInCents'`
       Expected: 1000 (integer, no decimal point)
       Verify integer: `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 10, "height": 10}' | jq '.priceInCents % 1'`
       Expected: 0 (confirms no fractional component)
       `curl -s -X POST http://localhost:3000/api/pricing -H "Content-Type: application/json" -d '{"width": 200, "height": 200}' | jq '.priceInCents % 1'`
       Expected: 0 (confirms integer cents at max boundary too)
    9. Stop dev server: kill the background process
  </verify>
  <done>
    POST /api/pricing endpoint exists and:
    - Returns 200 with PricingResponse for valid dimensions (10-200cm)
    - Returns 400 with field-level errors for invalid dimensions
    - Returns 500 for unexpected errors
    - Normalizes dimensions (71cm -> 80cm) and includes normalized values in response
    - Returns integer cents only (priceInCents % 1 === 0 for all responses)
    - All curl tests above pass with dev server running
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Dev server starts successfully with `npm run dev`
3. POST /api/pricing returns correct prices for valid inputs
4. POST /api/pricing returns 400 with clear error details for invalid inputs
5. Response always contains integer priceInCents (verified via `jq '.priceInCents % 1'` returning 0)
6. Normalization is visible in response (originalWidth vs normalizedWidth)
7. Boundary values work: 10cm (min), 200cm (max), values that round up
</verification>

<success_criteria>
- POST /api/pricing endpoint is functional and handles all validation/calculation scenarios
- Three-layer architecture is complete: Route Handler -> Zod schema -> pure calculator
- All 15 Phase 2 requirements (PRICE-01 through PRICE-07, DIM-04 through DIM-11) are covered
- Price calculations use integer cents throughout (verified with modulo check)
- Error responses provide actionable field-level details
</success_criteria>

<output>
After completion, create `.planning/phases/02-pricing-engine---validation/02-02-SUMMARY.md`
</output>
