---
phase: 11-product-catalog-foundation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/app/api/pricing/route.ts
  - src/lib/pricing/validator.ts
  - src/components/dimension-configurator.tsx
  - src/lib/cart/utils.ts
  - src/lib/cart/store.ts
  - src/lib/shopify/draft-order.ts
autonomous: true

must_haves:
  truths:
    - "API route /api/pricing accepts productId and loads the correct product's pricing matrix"
    - "API returns 404 for invalid productId or missing pricing matrix"
    - "Dimension configurator sends productId to the pricing API"
    - "Cart item IDs use human-readable format: ${productId}-${width}x${height}"
    - "Old cart items (without productId) are cleared on load via migration"
    - "Shopify draft order includes productId and dimension units in customAttributes"
  artifacts:
    - path: "src/app/api/pricing/route.ts"
      provides: "Pricing API that loads product and matrix by productId"
      exports: ["POST"]
    - path: "src/lib/pricing/validator.ts"
      provides: "Zod schema for pricing request with productId"
      exports: ["PricingRequestSchema"]
    - path: "src/lib/cart/utils.ts"
      provides: "Human-readable cart item ID generation"
      exports: ["generateCartItemId"]
    - path: "src/lib/cart/store.ts"
      provides: "Cart store with migration for old format"
      exports: ["useCartStore"]
    - path: "src/lib/shopify/draft-order.ts"
      provides: "Draft order with productId and dimension units in customAttributes"
      exports: ["createDraftOrder"]
  key_links:
    - from: "src/app/api/pricing/route.ts"
      to: "src/lib/product/catalog.ts"
      via: "getProduct(productId) lookup"
      pattern: "getProduct\\(.*productId"
    - from: "src/app/api/pricing/route.ts"
      to: "src/lib/pricing/loader.ts"
      via: "loadPricingMatrix(product.pricingMatrixPath)"
      pattern: "loadPricingMatrix\\(.*pricingMatrixPath"
    - from: "src/app/api/pricing/route.ts"
      to: "src/lib/pricing/calculator.ts"
      via: "calculatePrice(matrix, width, height)"
      pattern: "calculatePrice\\(matrix"
    - from: "src/components/dimension-configurator.tsx"
      to: "src/app/api/pricing/route.ts"
      via: "POST fetch with productId in body"
      pattern: "productId.*width.*height"
    - from: "src/lib/cart/store.ts"
      to: "src/lib/cart/utils.ts"
      via: "generateCartItemId with new format"
      pattern: "generateCartItemId"
---

<objective>
Wire the multi-product pricing flow end-to-end: API route loads product and matrix by productId, dimension configurator sends productId, cart uses human-readable IDs with migration, and Shopify draft order includes product metadata.

Purpose: Completes the multi-product data architecture by connecting all the pieces from Plan 01 (catalog, pricing engine, loader) into the working application flow.

Output: Updated API route, validator, dimension configurator, cart utilities, cart store, and Shopify draft order integration.
</objective>

<execution_context>
@/Users/robinkonijnendijk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/robinkonijnendijk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-product-catalog-foundation/11-CONTEXT.md
@.planning/phases/11-product-catalog-foundation/11-01-SUMMARY.md

Source files to modify:
@src/app/api/pricing/route.ts
@src/lib/pricing/validator.ts
@src/components/dimension-configurator.tsx
@src/lib/cart/utils.ts
@src/lib/cart/store.ts
@src/lib/shopify/draft-order.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update pricing API route and validator to accept productId, update dimension configurator</name>
  <files>
    src/app/api/pricing/route.ts
    src/lib/pricing/validator.ts
    src/components/dimension-configurator.tsx
  </files>
  <action>
    **1. Update `src/lib/pricing/validator.ts`** — Add productId to the validation schema:

    Rename `DimensionInputSchema` to `PricingRequestSchema` (more accurate name now that it includes productId). Keep the old export as an alias for backward compatibility if any other file imports it, but check first with grep — if only the route.ts imports it, just rename.

    New schema:
    ```typescript
    export const PricingRequestSchema = z.object({
      productId: z.string().min(1, 'Product ID is required'),
      width: z
        .number()
        .min(10, 'Width must be at least 10cm')
        .max(200, 'Width must not exceed 200cm'),
      height: z
        .number()
        .min(10, 'Height must be at least 10cm')
        .max(200, 'Height must not exceed 200cm'),
    });

    export type PricingRequest = z.infer<typeof PricingRequestSchema>;
    ```

    Also keep `DimensionInputSchema` as an alias (`export const DimensionInputSchema = PricingRequestSchema;`) ONLY if other files import it. If only route.ts uses it, remove the old name entirely.

    **2. Rewrite `src/app/api/pricing/route.ts`** — Full orchestration: validate input, load product, load matrix, calculate price:

    ```typescript
    import { NextResponse } from "next/server";
    import { PricingRequestSchema } from "@/lib/pricing/validator";
    import { calculatePrice } from "@/lib/pricing/calculator";
    import { getProduct } from "@/lib/product/catalog";
    import { loadPricingMatrix } from "@/lib/pricing/loader";

    export async function POST(request: Request) {
      try {
        const body = await request.json();

        // Validate request with Zod (now includes productId)
        const result = PricingRequestSchema.safeParse(body);
        if (!result.success) {
          return NextResponse.json(
            { error: "Invalid request", details: result.error.issues },
            { status: 400 }
          );
        }

        const { productId, width, height } = result.data;

        // Load product metadata
        const product = getProduct(productId);
        if (!product) {
          return NextResponse.json(
            { error: "Product not found" },
            { status: 404 }
          );
        }

        // Load pricing matrix for this product
        let matrix;
        try {
          matrix = await loadPricingMatrix(product.pricingMatrixPath);
        } catch {
          return NextResponse.json(
            { error: "Pricing data unavailable" },
            { status: 404 }
          );
        }

        // Calculate price using product's matrix
        const pricingResponse = calculatePrice(matrix, width, height);
        return NextResponse.json(pricingResponse, { status: 200 });

      } catch (error) {
        const message = error instanceof Error ? error.message : "Unknown error";
        return NextResponse.json(
          { error: "Internal server error", message },
          { status: 500 }
        );
      }
    }
    ```

    Key changes from current implementation:
    - Imports `getProduct` from catalog and `loadPricingMatrix` from loader
    - Extracts `productId` from validated body
    - Returns 404 for unknown product or missing matrix
    - Passes loaded matrix to `calculatePrice(matrix, width, height)`
    - Error handling follows existing pattern (400 for validation, 404 for not found, 500 for unexpected)

    **3. Update `src/components/dimension-configurator.tsx`** — Send productId in API request body:

    Find the fetch call (around line 96-104) that sends `{ width: widthNum, height: heightNum }` and add `productId`:
    ```typescript
    body: JSON.stringify({
      productId,    // NEW: from component props
      width: widthNum,
      height: heightNum
    })
    ```

    The component already receives `productId` as a prop from the product page, so no prop changes needed. Also add handling for 404 responses (product not found or pricing unavailable):
    ```typescript
    } else if (response.status === 404) {
      setError('Product pricing unavailable')
      setPrice(null)
    }
    ```

    Add this between the existing 400 and catch-all error handling blocks.
  </action>
  <verify>
    Run `npx tsc --noEmit` — should have zero errors (the calculator signature mismatch from Plan 01 is now resolved).

    Start dev server (`npm run dev`) and test:
    1. Navigate to `/products/rollerblinds-white`, enter 100x150 dimensions — price should appear
    2. Navigate to `/products/rollerblinds-black`, enter 100x150 — price should appear (same value, matrices are identical for now)
    3. Test invalid productId: `curl -X POST http://localhost:3000/api/pricing -H 'Content-Type: application/json' -d '{"productId":"nonexistent","width":100,"height":150}'` — should return 404

    Run `npm run build` to verify the production build succeeds.
  </verify>
  <done>
    API route `/api/pricing` accepts `{productId, width, height}`, loads correct product and pricing matrix, returns calculated price. Returns 404 for invalid productId. Dimension configurator sends productId with every pricing request. TypeScript compiles cleanly. Build succeeds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cart ID format, add migration, and enhance Shopify draft order customAttributes</name>
  <files>
    src/lib/cart/utils.ts
    src/lib/cart/store.ts
    src/lib/shopify/draft-order.ts
  </files>
  <action>
    **1. Update `src/lib/cart/utils.ts`** — Change `generateCartItemId` to use human-readable format per user decision:

    Current: `${productId}-${hash}` (hash of stringified options)
    New: `${productId}-${width}x${height}` (human-readable)

    ```typescript
    /**
     * Generates a unique cart item ID by combining product ID and dimensions
     * Format: ${productId}-${width}x${height}
     *
     * Examples:
     * - rollerblinds-white-150x200
     * - rollerblinds-black-150x200  (same dimensions, different product = unique ID)
     */
    export function generateCartItemId(
      productId: string,
      options: { width: number; height: number }
    ): string {
      return `${productId}-${options.width}x${options.height}`;
    }
    ```

    Keep `generateOptionsSignature` function as-is — it's still used for the `optionsSignature` field on CartItem (which provides a hash for potential future use). The only change is in `generateCartItemId`.

    **2. Update `src/lib/cart/store.ts`** — Add cart migration to clear old-format items:

    Add `version: 2` to the persist config and a `migrate` function that clears old carts:

    ```typescript
    {
      name: 'cart-storage',
      version: 2,   // NEW: bump version to trigger migration
      storage: createJSONStorage(() => storageWithTTL),
      partialize: (state) => ({ items: state.items }),
      migrate: (persistedState, version) => {
        // Version 0 or 1 = old format (no productId in cart ID, or hash-based IDs)
        // Clear cart and start fresh
        if (version < 2) {
          console.warn('Cart format changed (v2: productId in cart IDs) - clearing old items');
          return { items: [] };
        }
        return persistedState as { items: CartItem[] };
      },
    }
    ```

    The Zustand persist middleware calls `migrate` when the stored version doesn't match the current version. This handles the user decision: "Clear old carts (pre-productId format) on load."

    **3. Update `src/lib/shopify/draft-order.ts`** — Enhance customAttributes per user decision:

    Current customAttributes: `[{ key: "width", value: "150" }, { key: "height", value: "200" }]`
    New customAttributes with units and productId:
    ```typescript
    customAttributes: [
      { key: "Width", value: `${item.options.width}cm` },
      { key: "Height", value: `${item.options.height}cm` },
      { key: "Product ID", value: item.productId }
    ]
    ```

    Changes:
    - Capitalize keys ("Width", "Height") for better display on Shopify orders/invoices
    - Add "cm" unit suffix to dimension values per user decision
    - Add "Product ID" attribute to track which catalog product was ordered
    - Keep the rest of the draft order logic unchanged (title format, pricing, error handling)

    Note: The user decision mentions using `customAttributes` (GraphQL API term). The existing code already uses this field name correctly — no terminology change needed.
  </action>
  <verify>
    Run `npx tsc --noEmit` — zero errors.
    Run `npm run build` — build succeeds.

    Manual testing in dev server:
    1. Clear localStorage (`localStorage.removeItem('cart-storage')` in browser console)
    2. Navigate to `/products/rollerblinds-white`, enter 100x150, click "Add to Cart"
    3. Check localStorage: `JSON.parse(localStorage.getItem('cart-storage'))` — verify item ID is `rollerblinds-white-100x150`
    4. Navigate to `/products/rollerblinds-black`, enter 100x150, click "Add to Cart"
    5. Check cart has 2 items (not merged — different products, same dimensions)
    6. Add same product+dimensions again — verify quantity increments to 2

    Test migration: Set old cart format in localStorage, reload page, verify cart is cleared:
    ```javascript
    localStorage.setItem('cart-storage', JSON.stringify({ state: { items: [{ id: 'old-format' }] }, timestamp: Date.now() }));
    ```
    Reload — cart should be empty.
  </verify>
  <done>
    Cart item IDs use human-readable `${productId}-${width}x${height}` format. Old carts are cleared via Zustand persist migration (version 2). Shopify draft order includes "Width", "Height" with units and "Product ID" in customAttributes. All existing functionality preserved. TypeScript compiles and builds cleanly.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` — zero errors
2. `npm run build` — success
3. POST `/api/pricing` with `{productId: "rollerblinds-white", width: 100, height: 150}` returns price
4. POST `/api/pricing` with `{productId: "nonexistent", width: 100, height: 150}` returns 404
5. POST `/api/pricing` without productId returns 400
6. Cart item IDs follow `${productId}-${width}x${height}` format
7. Different products with same dimensions create separate cart items
8. Same product+dimensions increments quantity
9. Old format carts are cleared on load
10. Shopify customAttributes include "Width" with unit, "Height" with unit, and "Product ID"
</verification>

<success_criteria>
- Pricing API accepts productId and loads correct pricing matrix per product
- 404 returned for invalid productId or missing pricing matrix
- Dimension configurator sends productId in every pricing request
- Cart uses human-readable ID format with productId prefix
- Cart migration clears pre-v2 carts
- Shopify draft order includes product metadata in customAttributes
- Full TypeScript compilation and production build succeed
</success_criteria>

<output>
After completion, create `.planning/phases/11-product-catalog-foundation/11-02-SUMMARY.md`
</output>
