# Phase 13: Blog Foundation & Content Marketing - Research

**Researched:** 2026-02-13
**Domain:** MDX Blog with Velite, Next.js App Router
**Confidence:** HIGH

## Summary

Phase 13 implements a blog foundation using Velite for type-safe MDX content management in a Next.js 14+ App Router application. The research confirms that Velite is the appropriate choice for this use case, providing Zod-based schema validation, automatic TypeScript type generation, and seamless integration with Next.js build processes.

The standard stack consists of Velite (v0.3.1, latest as of Dec 2025) for content management, reading-time for calculating estimated reading time, and @tailwindcss/typography for beautiful blog post typography. Velite has emerged as the preferred alternative to the now-abandoned Contentlayer, offering similar developer experience with active maintenance.

The implementation will follow Next.js App Router patterns with server components, use dynamic routes for blog posts (`/blog/[slug]`), and leverage Velite's built-in MDX compilation with custom component mapping. The footer already includes blog links (verified in existing codebase), satisfying NAV-07 out of the box.

**Primary recommendation:** Use Velite with next.config.mjs integration for automatic builds in development and production. Structure content in a `/content/posts/` directory with Velite schema defining title, slug, date, excerpt, and MDX content. Use @tailwindcss/typography prose classes for responsive typography.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| velite | ^0.3.1 | Type-safe MDX content management with Zod validation | Industry standard replacement for abandoned Contentlayer; actively maintained, used by Ark UI, Chakra UI, Park UI |
| @tailwindcss/typography | latest | Beautiful default typography for MDX content | Official Tailwind plugin for prose content; hand-designed by professional designers |
| reading-time | ^1.5.0 | Calculate estimated reading time from text | De facto standard (200 WPM calculation); simple, reliable, widely adopted |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| date-fns | ^4.0.0 | Format blog post dates | When displaying dates in blog listings/details (v4 has first-class timezone support) |
| rehype-slug | latest | Add IDs to headings for anchor links | For linkable headings in blog posts (optional but recommended) |
| rehype-autolink-headings | latest | Auto-link heading IDs | For automatic heading anchors (optional enhancement) |
| remark-gfm | latest | GitHub Flavored Markdown support | For tables, strikethrough, task lists in MDX (optional) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Velite | @next/mdx | @next/mdx requires files in app directory, no content validation, no type generation. Use only for single-page MDX routes |
| Velite | next-mdx-remote | Requires manual file loading, RSC support still unstable (as of 2026), no type safety. Use for remote content only |
| Velite | Contentlayer | Contentlayer abandoned in 2024. Do not use for new projects |
| reading-time | Manual calculation | Hand-rolling reading time misses edge cases (code blocks, tables). Always use library |

**Installation:**
```bash
npm install velite zod reading-time date-fns
npm install -D @tailwindcss/typography
```

## Architecture Patterns

### Recommended Project Structure
```
/Users/robinkonijnendijk/Desktop/pure-blinds/
├── content/                    # Velite content source
│   └── posts/                  # Blog posts
│       ├── choosing-blinds-guide.mdx
│       ├── blind-care-tips.mdx
│       └── measuring-windows.mdx
├── src/
│   ├── app/
│   │   └── blog/
│   │       ├── page.tsx        # Blog listing (/blog)
│   │       └── [slug]/
│   │           └── page.tsx    # Post detail (/blog/[slug])
│   └── components/
│       └── mdx/
│           └── mdx-content.tsx # MDX renderer component
├── .velite/                    # Generated by Velite (gitignored)
│   └── index.js                # Type-safe post data export
├── public/
│   └── static/                 # Velite-processed images (gitignored)
├── velite.config.ts            # Velite configuration
└── next.config.mjs             # Next.js config (ESM for Velite)
```

### Pattern 1: Velite Configuration with Reading Time
**What:** Define posts collection schema with Zod validation and computed fields
**When to use:** Always - this is the foundation of type-safe content
**Example:**
```typescript
// velite.config.ts
// Source: https://velite.js.org/guide/define-collections
import { defineConfig, defineCollection, s } from 'velite'
import readingTime from 'reading-time'

const posts = defineCollection({
  name: 'Post',
  pattern: 'posts/**/*.mdx',
  schema: s
    .object({
      title: s.string().max(99),
      slug: s.slug('blog'),
      date: s.isodate(),
      excerpt: s.excerpt(),
      body: s.mdx()
    })
    .transform((data) => ({
      ...data,
      readingTime: readingTime(data.body).text,
      permalink: `/blog/${data.slug}`
    }))
})

export default defineConfig({
  root: 'content',
  output: {
    data: '.velite',
    assets: 'public/static',
    base: '/static/',
    name: '[name]-[hash:6].[ext]',
    clean: true
  },
  collections: { posts }
})
```

### Pattern 2: Next.js Config Integration (Recommended)
**What:** Integrate Velite build process with Next.js dev/build using top-level await
**When to use:** Always - preferred method for Next.js integration
**Example:**
```javascript
// next.config.mjs
// Source: https://velite.js.org/guide/with-nextjs
import { build } from 'velite'

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Your existing config
}

const isDev = process.argv.includes('dev')
const isBuild = process.argv.includes('build')

if (isDev || isBuild) {
  await build({ watch: isDev, clean: !isDev })
}

export default nextConfig
```

### Pattern 3: Blog Listing Page
**What:** Server component that imports generated Velite data and displays cards
**When to use:** For /blog route
**Example:**
```typescript
// src/app/blog/page.tsx
// Source: https://velite.js.org/guide/quick-start + Next.js App Router best practices
import { posts } from '@/.velite'
import { format } from 'date-fns'
import Link from 'next/link'
import Breadcrumbs from '@/components/layout/breadcrumbs'

export default function BlogPage() {
  const sortedPosts = posts.sort((a, b) =>
    new Date(b.date).getTime() - new Date(a.date).getTime()
  )

  return (
    <div className="px-6 py-12 sm:py-16">
      <div className="mx-auto max-w-5xl">
        <Breadcrumbs items={[
          { label: "Home", href: "/" },
          { label: "Blog", current: true }
        ]} />

        <div className="text-center max-w-2xl mx-auto mb-12">
          <p className="text-sm font-semibold uppercase tracking-wider text-muted">
            Blog
          </p>
          <h1 className="mt-3 text-3xl font-light tracking-tight sm:text-4xl">
            Guides & Tips
          </h1>
        </div>

        <div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-3">
          {sortedPosts.map((post) => (
            <Link
              key={post.slug}
              href={post.permalink}
              className="group"
            >
              <article className="flex flex-col h-full border border-neutral-200 rounded-lg p-6 hover:border-neutral-300 transition-colors">
                <time className="text-sm text-muted">
                  {format(new Date(post.date), 'MMMM d, yyyy')}
                </time>
                <h2 className="mt-2 text-xl font-semibold group-hover:text-neutral-600 transition-colors">
                  {post.title}
                </h2>
                <p className="mt-3 text-sm text-muted line-clamp-3 flex-grow">
                  {post.excerpt}
                </p>
                <div className="mt-4 pt-4 border-t border-neutral-100">
                  <span className="text-sm text-muted">{post.readingTime}</span>
                </div>
              </article>
            </Link>
          ))}
        </div>
      </div>
    </div>
  )
}
```

### Pattern 4: Blog Post Detail Page
**What:** Dynamic route that renders individual posts with MDX content
**When to use:** For /blog/[slug] route
**Example:**
```typescript
// src/app/blog/[slug]/page.tsx
// Source: Next.js App Router dynamic routes + Velite MDX patterns
import { posts } from '@/.velite'
import { notFound } from 'next/navigation'
import { format } from 'date-fns'
import Breadcrumbs from '@/components/layout/breadcrumbs'
import { MDXContent } from '@/components/mdx/mdx-content'

export async function generateStaticParams() {
  return posts.map((post) => ({
    slug: post.slug
  }))
}

export async function generateMetadata({ params }: { params: Promise<{ slug: string }> }) {
  const { slug } = await params
  const post = posts.find((p) => p.slug === slug)

  if (!post) return {}

  return {
    title: post.title,
    description: post.excerpt
  }
}

export default async function BlogPostPage({
  params
}: {
  params: Promise<{ slug: string }>
}) {
  const { slug } = await params
  const post = posts.find((p) => p.slug === slug)

  if (!post) {
    notFound()
  }

  return (
    <div className="px-6 py-12 sm:py-16">
      <div className="mx-auto max-w-3xl">
        <Breadcrumbs items={[
          { label: "Home", href: "/" },
          { label: "Blog", href: "/blog" },
          { label: post.title, current: true }
        ]} />

        <article className="mt-8">
          <header className="mb-8">
            <time className="text-sm text-muted">
              {format(new Date(post.date), 'MMMM d, yyyy')} • {post.readingTime}
            </time>
            <h1 className="mt-2 text-4xl font-light tracking-tight sm:text-5xl">
              {post.title}
            </h1>
            <p className="mt-4 text-lg text-muted">
              {post.excerpt}
            </p>
          </header>

          <div className="prose prose-neutral max-w-none">
            <MDXContent code={post.body} />
          </div>
        </article>
      </div>
    </div>
  )
}
```

### Pattern 5: MDX Content Renderer
**What:** Component that executes Velite-compiled MDX code with custom components
**When to use:** For rendering MDX body content from Velite
**Example:**
```typescript
// src/components/mdx/mdx-content.tsx
// Source: https://velite.js.org/guide/using-mdx
'use client'

import * as runtime from 'react/jsx-runtime'
import Image from 'next/image'

const useMDXComponent = (code: string) => {
  const fn = new Function(code)
  return fn({ ...runtime }).default
}

const components = {
  Image,
  // Add custom components here
}

export function MDXContent({ code }: { code: string }) {
  const Component = useMDXComponent(code)
  return <Component components={components} />
}
```

### Pattern 6: Responsive Typography with Tailwind Prose
**What:** Use @tailwindcss/typography for consistent, responsive blog post styling
**When to use:** Wrapper for MDX content in blog post detail pages
**Example:**
```tsx
// Source: https://tailwindcss.com/docs/typography-plugin
// Responsive prose sizing with breakpoint modifiers
<article className="prose prose-neutral md:prose-lg lg:prose-xl max-w-none
  prose-headings:font-semibold prose-headings:tracking-tight
  prose-a:text-foreground prose-a:no-underline hover:prose-a:underline">
  <MDXContent code={post.body} />
</article>
```

### Anti-Patterns to Avoid
- **Using @next/mdx for content collections:** @next/mdx is designed for pages, not content management. It lacks validation, type generation, and structured data handling that Velite provides.
- **Global client component mapping in MDX:** Don't map heavy client components globally in mdx-components.tsx. Use dynamic imports or explicit wrapper components to avoid bloating every MDX page.
- **Manual frontmatter parsing:** Velite handles frontmatter validation with Zod. Don't use gray-matter or manual parsing.
- **Relative imports in MDX files:** Velite compiles MDX to function strings. Don't import components inside MDX files - pass them via the components prop instead.
- **Hand-rolling slug generation:** Use Velite's `s.slug()` schema which handles validation and uniqueness.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Reading time calculation | Custom word counter with WPM math | `reading-time` package | Misses edge cases: code blocks, tables, images. Wrong WPM for technical content. Library is battle-tested. |
| MDX compilation | Custom remark/rehype pipeline | Velite's `s.mdx()` | Velite handles compilation, bundling, and optimization. Custom pipelines miss performance optimizations and error handling. |
| Type generation from content | Manual TypeScript interfaces | Velite's Zod inference | Schema and types drift. Velite auto-generates types from Zod schemas, guarantees sync. |
| Slug generation/validation | `title.toLowerCase().replace()` | Velite's `s.slug()` | Misses unicode, collisions, special chars. Velite validates uniqueness across collection. |
| Image optimization in MDX | Manual next/image wrappers | Velite's `s.image()` | Velite automatically resolves relative paths, optimizes, and moves to public. Manual handling breaks on build. |
| Date parsing | `new Date(string)` | Velite's `s.isodate()` + date-fns | Date parsing is locale/timezone sensitive. Velite validates ISO format, date-fns formats consistently. |

**Key insight:** Content management has deceptive complexity. Validation (schema), transformation (slugs, dates, images), and compilation (MDX) require battle-tested libraries. Velite consolidates these into a single type-safe pipeline. Custom solutions create technical debt and break on edge cases.

## Common Pitfalls

### Pitfall 1: Using .ts Extension for next.config (with Velite)
**What goes wrong:** Velite integration requires top-level await, which isn't supported in TypeScript config files
**Why it happens:** Project starts with next.config.ts, developers try to add Velite integration without converting to .mjs
**How to avoid:** Convert next.config.ts to next.config.mjs when adding Velite. ESM is required for top-level await.
**Warning signs:** Build errors about "await is only valid in async function" or "unexpected token 'await'"

### Pitfall 2: Not Ignoring .velite and public/static Directories
**What goes wrong:** Git tracks thousands of generated files, massive diffs, merge conflicts in generated code
**Why it happens:** Developers forget to update .gitignore after Velite setup
**How to avoid:** Add to .gitignore immediately:
```
.velite
public/static
```
**Warning signs:** PR diffs showing .velite/index.js or public/static/* changes

### Pitfall 3: Forgetting TypeScript Paths for .velite Import
**What goes wrong:** Import errors: "Cannot find module '@/.velite'" despite successful Velite build
**Why it happens:** tsconfig.json has `"@/*": ["./src/*"]` but .velite is in project root, not src/
**How to avoid:** Velite generates to project root by default. Either:
1. Import using relative path: `import { posts } from '../.velite'`
2. OR update tsconfig.json to include root-level imports
**Warning signs:** TypeScript errors in blog pages despite successful `npx velite` build

### Pitfall 4: Using Client Components for Blog Listing
**What goes wrong:** Unnecessary JavaScript, slower page loads, no SSG benefits
**Why it happens:** Developers default to 'use client' or copy patterns from interactive features
**How to avoid:** Blog listing and detail pages should be Server Components. Velite data is imported at build time, no runtime fetching needed. Only MDXContent needs 'use client' (for Function() execution).
**Warning signs:** Seeing hydration in blog listing page, Network tab shows JSON payload for static content

### Pitfall 5: Not Sorting Posts by Date
**What goes wrong:** Blog listing shows posts in random/alphabetical order instead of chronological
**Why it happens:** Velite returns posts in file system order, not date order
**How to avoid:** Always sort posts in listing page:
```typescript
const sortedPosts = posts.sort((a, b) =>
  new Date(b.date).getTime() - new Date(a.date).getTime()
)
```
**Warning signs:** "Why is my oldest post showing first?"

### Pitfall 6: Missing prose-neutral for Tailwind Typography
**What goes wrong:** Blog posts use default prose-gray which doesn't match site's neutral color scheme
**Why it happens:** Default @tailwindcss/typography uses gray-700 for text, conflicts with site's foreground/muted tokens
**How to avoid:** Use `prose-neutral` variant to match existing Tailwind neutral colors:
```tsx
<div className="prose prose-neutral">
```
**Warning signs:** Blog text looks different shade than rest of site

### Pitfall 7: Hardcoding Blog Link in Footer
**What goes wrong:** Footer blog link breaks if blog route changes, no single source of truth
**Why it happens:** This is actually not a pitfall for this project - footer already has correct `/blog` link hardcoded and unlikely to change
**How to avoid:** For this phase, no action needed. Footer from Phase 6 already includes blog link (verified in research).
**Warning signs:** N/A - current implementation is acceptable

### Pitfall 8: Not Using generateStaticParams
**What goes wrong:** Blog post pages render on-demand instead of at build time, slower performance
**Why it happens:** Developers forget that dynamic routes need explicit SSG configuration in App Router
**How to avoid:** Always add generateStaticParams to dynamic blog post page:
```typescript
export async function generateStaticParams() {
  return posts.map((post) => ({ slug: post.slug }))
}
```
**Warning signs:** Blog post pages load slowly, build output doesn't show static paths for /blog/[slug]

## Code Examples

Verified patterns from official sources:

### Example 1: Complete Velite Configuration for Blog
```typescript
// velite.config.ts
// Source: https://velite.js.org/guide/define-collections
import { defineConfig, defineCollection, s } from 'velite'
import readingTime from 'reading-time'

const posts = defineCollection({
  name: 'Post',
  pattern: 'posts/**/*.mdx',
  schema: s
    .object({
      title: s.string().max(99),
      slug: s.slug('blog'),
      date: s.isodate(),
      excerpt: s.excerpt(),
      body: s.mdx()
    })
    .transform((data) => ({
      ...data,
      readingTime: readingTime(data.body).text,
      permalink: `/blog/${data.slug}`
    }))
})

export default defineConfig({
  root: 'content',
  output: {
    data: '.velite',
    assets: 'public/static',
    base: '/static/',
    name: '[name]-[hash:6].[ext]',
    clean: true
  },
  collections: { posts }
})
```

### Example 2: Sample Blog Post MDX File
```mdx
---
title: "The Complete Guide to Choosing Window Blinds"
slug: "choosing-blinds-guide"
date: "2025-01-15"
excerpt: "Learn how to select the perfect blinds for your home with our comprehensive guide covering materials, styles, and measurements."
---

Choosing the right window blinds can transform your space. Here's what you need to know.

## Understanding Blind Types

There are three main categories of blinds:

### Roller Blinds
Perfect for modern spaces, roller blinds offer clean lines and easy operation.

### Venetian Blinds
Classic and versatile, venetian blinds provide excellent light control.

### Textile Blinds
For a softer look, textile blinds add warmth and texture to any room.

## Measuring Your Windows

Accurate measurements are crucial for a perfect fit:

1. Measure the width at three points (top, middle, bottom)
2. Measure the height at three points (left, center, right)
3. Use the smallest measurement for each dimension

**Pro tip:** Always measure twice to avoid costly mistakes!
```

### Example 3: Reading Time Integration
```typescript
// In velite.config.ts schema transform
// Source: https://www.npmjs.com/package/reading-time
import readingTime from 'reading-time'

.transform((data) => ({
  ...data,
  readingTime: readingTime(data.body).text  // Returns "5 min read"
}))

// Alternative with options
.transform((data) => {
  const stats = readingTime(data.body, { wordsPerMinute: 200 })
  return {
    ...data,
    readingTime: stats.text,        // "5 min read"
    readingMinutes: stats.minutes,  // 5
    wordCount: stats.words          // 1000
  }
})
```

### Example 4: Date Formatting with date-fns
```typescript
// In blog listing/detail pages
// Source: https://date-fns.org/
import { format } from 'date-fns'

// Blog listing - short format
format(new Date(post.date), 'MMMM d, yyyy')  // "January 15, 2025"

// Blog detail - with day of week
format(new Date(post.date), 'EEEE, MMMM d, yyyy')  // "Wednesday, January 15, 2025"

// Relative time (requires add-on)
import { formatDistance } from 'date-fns'
formatDistance(new Date(post.date), new Date(), { addSuffix: true })  // "3 days ago"
```

### Example 5: Blog Card Grid with Tailwind
```tsx
// Source: Tailwind CSS responsive grid best practices
// Auto-fit pattern: as many columns as fit without making cards too narrow
<div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-3">
  {sortedPosts.map((post) => (
    <Link key={post.slug} href={post.permalink} className="group">
      <article className="flex flex-col h-full border border-neutral-200 rounded-lg p-6
        hover:border-neutral-300 transition-colors">
        {/* Card content */}
      </article>
    </Link>
  ))}
</div>

// Alternative: Fixed breakpoints
<div className="grid grid-cols-1 gap-6 md:grid-cols-2 lg:grid-cols-3">

// Alternative: Auto-fit with min-max (requires arbitrary values)
<div className="grid gap-6" style={{ gridTemplateColumns: 'repeat(auto-fit, minmax(20rem, 1fr))' }}>
```

### Example 6: Tailwind Prose Customization
```tsx
// Source: https://tailwindcss.com/docs/typography-plugin
// Basic usage
<article className="prose prose-neutral">
  <MDXContent code={post.body} />
</article>

// Responsive sizing
<article className="prose prose-neutral md:prose-lg lg:prose-xl">

// Custom heading styles
<article className="prose prose-neutral
  prose-headings:font-semibold
  prose-headings:tracking-tight
  prose-h1:text-4xl
  prose-h2:text-3xl">

// Custom link styles
<article className="prose prose-neutral
  prose-a:text-foreground
  prose-a:no-underline
  hover:prose-a:underline">

// Remove max-width constraint
<article className="prose prose-neutral max-w-none">
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Contentlayer | Velite | 2024 | Contentlayer abandoned; Velite is spiritual successor with similar API, active maintenance |
| @next/mdx file-based | Velite collections | 2023-2024 | File-based MDX requires files in app/, lacks validation/types. Collections separate content from code |
| next-mdx-remote | Velite s.mdx() | 2024-2025 | next-mdx-remote RSC support still unstable; Velite compiles at build time, type-safe |
| Manual frontmatter parsing (gray-matter) | Velite Zod schemas | 2024+ | Zod validation catches errors at build time, auto-generates types, eliminates runtime parsing |
| Moment.js for dates | date-fns v4 | 2024+ | Moment.js deprecated; date-fns v4 has first-class timezone support, tree-shakeable |
| CSS line-clamp hacks | Tailwind line-clamp utility | 2023+ | Tailwind 3.3+ includes line-clamp utility out of box, no custom CSS needed |

**Deprecated/outdated:**
- **Contentlayer**: Abandoned in 2024. Do not use for new projects. Migrate to Velite.
- **@next/mdx for blogs**: Not deprecated but wrong tool. Use for single-page MDX routes, not content collections.
- **next-mdx-remote with RSC**: RSC support marked unstable as of early 2026. Use Velite instead.
- **Webpack plugin approach for Velite**: Works but incompatible with Turbopack. Use next.config.mjs with top-level await.
- **Moment.js**: Deprecated. Use date-fns v4 or native Temporal (when stable).

## Open Questions

1. **Should we use remark/rehype plugins for enhanced MDX features?**
   - What we know: Velite supports remark/rehype plugins (remark-gfm for tables, rehype-slug for heading IDs, etc.)
   - What's unclear: Whether sample blog posts need these features, or if basic markdown is sufficient
   - Recommendation: Start without plugins. Add remark-gfm if sample posts need tables/task lists. Add rehype-slug if heading anchors are needed. Defer until PLAN phase based on sample post content.

2. **Do we need dark mode for blog posts?**
   - What we know: @tailwindcss/typography has prose-invert for dark mode
   - What's unclear: Whether site has dark mode implemented from previous phases
   - Recommendation: Check existing site theme in PLAN phase. If dark mode exists, add prose-invert. If not, defer to future phase.

3. **Should blog listing have filtering/search?**
   - What we know: Requirements don't mention filtering, only listing and detail pages
   - What's unclear: Whether 2-3 sample posts need filtering
   - Recommendation: Not needed for Phase 13 (only 2-3 posts). Defer filtering to future enhancement phase if blog grows.

4. **Do we need OG images for blog posts?**
   - What we know: Next.js App Router supports dynamic OG image generation
   - What's unclear: Whether Phase 13 scope includes social sharing optimization
   - Recommendation: Not in requirements. Defer to future SEO enhancement phase.

## Sources

### Primary (HIGH confidence)
- **Velite Official Docs** - https://velite.js.org/
  - Introduction: https://velite.js.org/guide/introduction
  - Quick Start: https://velite.js.org/guide/quick-start
  - Define Collections: https://velite.js.org/guide/define-collections
  - Using MDX: https://velite.js.org/guide/using-mdx
  - With Next.js: https://velite.js.org/guide/with-nextjs
- **Velite GitHub** - https://github.com/zce/velite (734 stars, v0.3.1 Dec 2025, active)
- **Next.js MDX Guide** - https://nextjs.org/docs/app/guides/mdx (Updated Feb 11, 2026)
- **Tailwind Typography** - https://tailwindcss.com/docs/typography-plugin
- **date-fns** - https://date-fns.org/ (v4.0 with timezone support)

### Secondary (MEDIUM confidence)
- **Building a blog with Next.js App Router and MDX** - https://www.alexchantastic.com/building-a-blog-with-next-and-mdx
- **Complete Guide: Integrating MDX Blog Feature into Next.js 14 App Router** - https://www.kishoregunnam.com/blog/implement-blog-feature-nextjs-14-app-router
- **Setting Up Velite for Next.js Content Management** - https://www.tehseen.io/blog/setup-velite
- **App Router pitfalls: common Next.js mistakes** - https://imidef.com/en/2026-02-11-app-router-pitfalls
- **Contentlayer has been Abandoned - Alternatives** - https://www.wisp.blog/blog/contentlayer-has-been-abandoned-what-are-the-alternatives
- **Refactoring ContentLayer to Velite** - https://www.mikevpeeren.nl/blog/refactoring-contentlayer-to-velite
- **Tailwind CSS Grid Template Columns: Practical Patterns for 2026** - https://thelinuxcode.com/tailwind-css-grid-template-columns-practical-patterns-for-2026-layouts/

### Tertiary (LOW confidence - flagged for validation)
- None - all findings verified through official docs or multiple sources

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Velite is well-documented, actively maintained (Dec 2025), used in production by major UI libraries. Next.js MDX guide updated Feb 11, 2026.
- Architecture: HIGH - Patterns sourced from official Velite docs, Next.js App Router conventions, and verified blog implementations.
- Pitfalls: MEDIUM-HIGH - Sourced from recent blog posts (2026-02-11), developer experience reports, and official documentation warnings. TypeScript path issue is educated guess based on typical setup.

**Research date:** 2026-02-13
**Valid until:** 2026-03-15 (30 days - Velite and Next.js are stable, slow-moving ecosystem)

**Research sources used:**
- Context7: Not used (Velite/blog stack not available in Context7)
- WebSearch: Extensive (15+ queries across Velite, MDX, Next.js App Router, Tailwind, date formatting)
- WebFetch: 6 fetches (Velite docs, Next.js MDX guide)
- Official docs: Primary source for all recommendations
